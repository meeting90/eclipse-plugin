module check

imports
  
  libstratego-lib
  include/C-without-macros
  lib/editor-common.generated
  lib/index-library
  lib/analysis-library
  types
  
rules // Type errors
  
  constraint-error:
    e@Assign(lhs, rhs) -> (e, $[Expected [<print-type> type1] but found [<print-type> type2].])
    where
      type1 := <type-of> lhs;
      type2 := <type-of> rhs;
      not(<is-assignable-to> (type1, type2))
      
  constraint-error:
    FunDecl(type, _, _, statements) -> errors
    where
      <collect-one(?Return(_))> statements; // At least one return statement can be found.
      methodType := <type-of> type;
      errors := <collect-all(constraint-error(|methodType), conc)> statements
      
  constraint-error(|methodType):
    e@Return(exp) -> (e, $[Expected [<print-type> methodType] but found [<print-type> type].])
    where
      type := <type-of> exp;
      not(<is-assignable-to> (methodType, type))
      
  constraint-error:
    FunDecl(type, _, _,  statements) -> (type, $[Function of type [<print-type> type1] does not return a value.])
    where
      type1 := <type-of> type;
      not(<is-assignable-to> (type1, <type-of> Void()));
      not(<collect-one(?Return(_))> statements)
  
rules // Other
  
  constraint-warning = fail
  constraint-note = fail
