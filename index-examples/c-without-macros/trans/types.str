module types

imports
	
  include/C-without-macros
  lib/index-library
  lib/analysis-library
  lib/analysis-library-internal
  names

signature constructors

  TypeDef     : Uri * TypeDef -> TypeDefData
  Ptr         : Type -> Type
  Struct      : Type -> Type

rules // Type projections
  	
  type-of:
    Pointer(x) -> Ptr(<type-of> x)
  	
  type-of:
    Deref(x) -> type
    where
      Ptr(type) := <type-of> x
  	
  type-of:
  	Ref(x) -> Ptr(<type-of> x)

  type-of:
    Void() -> Type("void")

  type-of:
  	Char() -> Type("char")
  	
  type-of:
  	Int() -> Type("int")
    
  type-of:
    IntLit(_) -> <type-of> Int()
    
  type-of:
    StrLit(_) -> <type-of> Pointer(Char())
    
  type-of:
    SizeOf(_) -> <type-of> Int()
   
  type-of:
    Cast(to, from) -> <type-of> to
  
  type-of:
    VarRef(v) -> <type-of> <index-lookup> v
    
  type-of:
    StructRef(s) -> <type-of> <index-lookup> s
    
  type-of:
    Access(_, p) -> <type-of> <index-lookup> p
    
  type-of:
    Assign(v, _) -> <type-of> <index-lookup> v
    
  type-of:
    Call(f, _) -> <type-of> <index-lookup> f

  type-of:
    Def(uri) -> type
    where
      switch id
        case ?Def([Struct(), typeName|_]): !Type(typeName{uri}) // Hack: no need to lookup here, just get struct name from uri.
        otherwise: <type-of> <index-get-data(|Type())> Def(uri)
      end;
      ?type
        
  // Recursion stoppers
  type-of:
    Type(x) -> Type(x)
    
  type-of:
    Ptr(x) -> Ptr(x)

rules // Lookup

  lookup-struct = lookup-struct(|[])
  lookup-struct(|seen):
    uri -> struct
    where
      if result := <index-get-value> TypeDef(uri, ()) then
        // There is a TypeDef for given uri, so it must be a Type.
        Type(_{uri2}) := <index-get-value> TypeDef(uri, ());
        
        not(<elem> (uri2, seen)); // Fail if already seen the typedeffed uri to prevent cyclic typedef.
        
        struct := <lookup-struct(|[uri2|seen])> uri2
      else
        // There is no TypeDef for given uri, so it must be a Struct.
        [Struct(), structName|_] := uri;
        struct := structName{uri}
      end
    
  try-lookup-struct = 
    try(sometd(\Type(t) -> Type(<lookup-struct> <index-uri> <index-lookup> t)\))
    
  try-get-struct-field(|prefix) =
    switch id
      case ?Type(_{uri}) :
        (<index-lookup-children(|Field(), prefix)> <lookup-struct> <index-uri-unwrap> uri) <+ ![]
      otherwise: 
        ![]
    end
	
rules // Comparison
	
  is-assignable-to:
    (to-type, from-type) -> to-type
    where
      <eq> (<try-lookup-struct> from-type, <try-lookup-struct> to-type)

rules // Utility
	  
  print-type = 
    switch id
      case ?Void() : !"void"
      case ?Char() : !"char"
      case ?Int() : !"int"
      case ?Type(t) : <strip-annos> t
      case ?Struct(t) : !$[struct [<print-type> t]]
      case ?StructRef(t) : !$[struct [<print-type> t]]
      case ?Pointer(t) : !$[[<print-type> t]*]
      case ?Ptr(t) : !$[[<print-type> t]*]
      case ?[type|[]] : <print-type> type
      case ?[type|types]; not (<?[]> types) : !$[[<print-type> type], [<print-type> types]] 
      otherwise : ?name#(_); !$[[name]]
    end
    
rules // Store
  
  adjust-index-def-data(store-results |namespace, path):
    TypeDef(definition, type) -> <store-results> TypeDef([namespace | path], <type-of> definition)
    