definition
module Common

exports

  lexical syntax

    [a-zA-Z][a-zA-Z0-9\_]* -> ID
    "-"? [0-9]+          -> INT

    StringChar*           -> UQSTRING
    "\"" StringChar* "\"" -> STRING
    ~[\"\n]               -> StringChar
    "\\\""                -> StringChar
    BackSlashChar         -> StringChar
    "\\"                  -> BackSlashChar

    [\ \t\n\r] -> LAYOUT

    [\*]                             -> CommentChar
    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT

    -> EOF

  lexical restrictions

    %% Ensure greedy matching for lexicals

    CommentChar   -/- [\/]
    INT           -/- [0-9]
    ID            -/- [a-zA-Z0-9\_]

    %% EOF may not be followed by any char

    EOF           -/- ~[]

    %% Backslash chars in strings may not be followed by " 

    BackSlashChar -/- [\"]

  context-free restrictions

    %% Ensure greedy matching for comments

    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\/]
    LAYOUT? -/- [\/].[\*]

module C-without-macros

imports Common

exports

	context-free start-symbols
	
    Start
	
	context-free syntax

		Include* Definition* -> Start {cons("Start")}
		
		"include" "\"" UQSTRING "\"" -> Include {cons("Include")}
		"include" "<" UQSTRING ">"   -> Include {cons("Include")}
		
		Type ID "(" {Param "," }* ")" "{" Stmt* "}" -> Definition {cons("FunDecl")}
		
		Type ID -> Param {cons("Param")}
		
		TypeDecl ";" -> Definition {cons("TypeDecl")}
		
		"typedef" Type ID          -> TypeDecl {cons("TypeDef")}
		"typedef" TypeDecl ID      -> TypeDecl {cons("TypeDef")} 
		"struct" ID "{" Field* "}" -> TypeDecl {cons("StructDecl")}
		
		Type ID ";" -> Field {cons("Field")}
		
		Type ID ";"       -> Stmt {cons("VarDecl")}
		Expr ";"          -> Stmt {cons("Stmt")}
		Expr "=" Expr ";" -> Stmt {cons("Assign")}
		"return" Expr ";" -> Stmt {cons("Return"), prefer}
		
		STRING                 -> Expr {cons("StrLit")}
		INT                    -> Expr {cons("IntLit")}
		ID "(" {Expr ","}* ")" -> Expr {cons("Call"), avoid}
		"sizeof" "(" Type ")"  -> Expr {cons("SizeOf")}
		Expr "." ID            -> Expr {cons("Access")}
		Expr "->" ID           -> Expr {cons("DerefAccess")}
		"*" Expr               -> Expr {cons("Deref")}
		"&" Expr               -> Expr {cons("Ref")}
		ID                     -> Expr {cons("VarRef")}
		"(" Type ")" Expr      -> Expr {cons("Cast")}
		
		ID          -> Type {cons("Type"), avoid}
		"char"      -> Type {cons("Char"), prefer} 
		"int"       -> Type {cons("Int"), prefer}
		"void"      -> Type {cons("Void"), prefer}
		Type "*"    -> Type {cons("Pointer"), left}
		"struct" ID -> Type {cons("StructRef")}