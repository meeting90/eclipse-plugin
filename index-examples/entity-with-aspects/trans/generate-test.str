module generate-test

imports
    
  libstratego-lib
  include/EntityWithAspects
  lib/editor-common.generated
  lib/index-library
  lib/analysis-library
  lib/analysis-library-internal
  types
  names

rules // Constants
  
  testgen-internal-file = !"/.internal/testgen"
  testgen-module-name = !"TestGen"
  
  testgen-num-files-per-group = !10
  testgen-num-groups = !1
  
  testgen-min-entities = !3
  testgen-max-entities = !5
  
  testgen-min-properties = !30
  testgen-max-properties = !100
  testgen-max-usertype-properties = !1
  
  testgen-min-functions = !1
  testgen-max-functions = !5
  
  testgen-min-statements = !3
  testgen-max-statements = !10
  
  testgen-min-aspects = !1
  testgen-max-aspects = !3
  
  testgen-min-pointcutadvices = !1
  testgen-max-pointcutadvices = !3
  
rules // Random primitives
  
  random-int(|min, max) = <int> <add> (<add> (<mul> (<subt> (max, <inc> min), <divr> (<abs> <next-random>, 1073741823)), min), 0.5)
  random-string = new; double-quote
  random-identifier = new; string-replace(|"_", "")
  
rules // Random elements
  
  random-type:
    _ -> type
    with
      primtypes := <primitive-types>;
      usertypes := <map(\Def([_, name|_]) -> name\)> <index-get-children(|Entity(), "")> Def([Module(), <testgen-module-name>]);
      (<take(|<testgen-max-usertype-properties>)> usertypes <+ !usertypes) => usertypes';
      types := <concat> [primtypes, primtypes, primtypes, primtypes, usertypes'];
      type := <random-list-item> types
  
rules // Random strategies
  
  testgen-apply(strat|num) = <range> num; map(strat)
  random-apply(strat|min-rand, max-rand) = testgen-apply(strat|<random-int(|min-rand, max-rand)>)
  random-list-item:
    list -> item
    where
      item := <index> (<random-int(|1, <inc> <length> list)>, list)
  
rules // Index manipulation
  
  testgen-add-ast(|file):
    ast -> ast3
    with
      <index-set-current-file> file;
      
      (Some(ast2), edefs) := <analyze-defs> Some(ast);
      defs := <map(Snd)> edefs;
      <index-add-all(|file)> defs;

      ast3 := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast2;
      data := <origin-track-forced(analyze-tree-data)> ast3;

      (data2, _) := <analyze-uses> data;
      <index-add-all(|file)> data2
  
rules // File writing
      
  testgen-write-file(|file):
  	ast -> None()
  	with
  		string := <pp-entitywithaspects-string> ast;
	    try(<mkdir> <abspath> <dirname> file);
	    <fclose> <fputs> (string, <fopen> (file, "w"));
	    <debug(!"Writing ")> file
  
rules // AST generation
  
  testgen:
  	(selected, position, ast, path, project-path) -> None()
  	with
  		groups := <map(\n -> (project-path, n)\)> <range> <testgen-num-groups>;
  		<map(testgen-group)> groups;
  		index-clear
  
  testgen-group:
    (project-path, group) -> None()
    with
      index-clear;
      files := <map(\n -> $[[project-path]/testgen/test_[group]_[n].ewa]\)> <range> <testgen-num-files-per-group>;
      <map(testgen-file)> <reverse> files
      
  testgen-file:
  	file -> None()
  	with
  		ast := <testgen-module>;
  		<testgen-add-ast(|file)> ast;
  		<testgen-write-file(|file)> ast
  
  testgen-module:
    _ -> mod
    with
      name := <testgen-module-name>;
      entities := <random-apply(testgen-entity|<testgen-min-entities>, <testgen-max-entities>)>;
      aspects := <random-apply(testgen-aspect|<testgen-min-aspects>, <testgen-max-aspects>)>;
      mod := Module(name, [], <conc> (entities, aspects))
    
  testgen-entity:
    _ -> entity
    with
      name := <random-identifier>;
      properties := <random-apply(testgen-property|<testgen-min-properties>, <testgen-max-properties>)>;
      functions := <random-apply(testgen-function(|properties)|<testgen-min-functions>, <testgen-max-functions>)>;
      entity := Entity(name, <conc> (properties, functions))
      
  testgen-property:
    _ -> property
    with
      name := <random-identifier>;
      type := <random-type>;
      property := Property(name, type)
      
  testgen-function(|properties):
    _ -> function
    with
      name := <random-identifier>;
      params := [];
      statement := Block(<random-apply(testgen-statement(|properties)|<testgen-min-statements>, <testgen-max-statements>)>);
      function := Function(name, params, statement)
      
  testgen-statement(|properties):
    _ -> statement
    with
        statement := Print(<testgen-expression(|properties)>)
      <+
        statement := Print(StringLit(<random-string>))
        
  testgen-expression(|properties):
    _ -> expression
    where
      Property(name, type) := <random-list-item> <filter(?Property(_, t); not(<is-primitive-type> t))> properties;
      def                  := Def([Type(), type, <testgen-module-name>]);
      Def([_, prop|_])     := <random-list-item> <index-get-children(|Property(), "")> def;
      expression           := PropAccess(Var(name), prop)

  testgen-aspect:
    _ -> aspect
    with
      name := <random-identifier>;
      pointcutadvices := <concat> <random-apply(testgen-pointcutadvice|<testgen-min-pointcutadvices>, <testgen-max-pointcutadvices>)>;
      aspect := Aspect(name, pointcutadvices)
    	
  testgen-pointcutadvice:
  	_ -> [pointcut, advice]
  	with
  		pointcutName := <random-identifier>;
  		adviceName := <random-identifier>;
  		adviceParamName := <random-identifier>;
  		type := <random-type>;
  		pointcut := Pointcut(pointcutName, [Param(<random-identifier>, type)], Assigned(type));
  		adviceType := <random-list-item> [Before(), After()];
  		advice := Advice(adviceName, adviceType, [Param(adviceParamName, type)], pointcutName, [Var(adviceParamName)], Print(Var(adviceParamName)))
